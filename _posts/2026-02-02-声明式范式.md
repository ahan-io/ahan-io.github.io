---
layout: post
title: "声明式范式"
author: "Ahan"
date: 2026-02-02 00:00:00
header-img: "img/post-bg-2015.jpg"
header-style: text
catalog:      true
tags:
    - Architecture
    - Stability
    - 开发范式
---
> 定义目标比定义过程更重要。
> 

在现代系统设计中，**声明式范式（Declarative Paradigm）**已成为构建稳定、可预期系统的重要基础。与命令式编程那种“告诉系统如何做”不同，声明式的核心思想是“告诉系统想要什么”，由系统自身去决定实现的过程。

这一范式将系统的运行状态与目标状态分离——开发者只需描述**期望的最终状态（desired state）**，系统会不断地将**实际状态（actual state）自动收敛到这一目标上。这种机制极大地提升了系统的自愈性（self-healing）与一致性（consistency）**。

一个最典型的例子便是 **Kubernetes**。

在 Kubernetes 中，用户不会直接告诉系统“请启动三个容器”；相反，他们编写一个 YAML 清单文件，描述目标状态为：

> “希望系统中始终有三个运行中的 Pod。”
> 

Kubernetes 的控制平面（Control Plane）随后会持续对比实际状态与期望状态：

- 如果某个 Pod 意外崩溃或节点下线，控制器会自动拉起新的 Pod；
- 如果用户修改了配置文件，将副本数改为 5，系统会自动扩容；
- 如果环境中有资源不足或调度失败的情况，系统会不断重试，直到达到目标。

这种“状态收敛”的思想，使得系统在面对不确定性（例如节点故障、网络抖动、调度延迟）时，依然能保持整体行为的稳定性。

换言之，**声明式范式让系统具备了工程化的自愈逻辑**：当变化不可避免时，系统自身成为最可靠的恢复机制。

正因为如此，声明式配置如今已广泛应用于现代基础设施，从 IaC（Infrastructure as Code）到 GitOps，再到云原生服务编排。它不仅是一种开发方式，更是一种“让系统更稳定、更可控”的设计哲学。

# 基于声明式范式的并发操作公式

在分布式系统中，并发修改是稳定性的天敌。传统做法往往通过加锁、事务等手段维持一致性，但这些方式复杂、脆弱且难以横向扩展。而**声明式范式**提供了一种更优雅、更具伸缩性的解决思路——让“状态的变化”转化为“状态的收敛”。

我们可以将这种思路抽象成一个通用公式：

> **声明式的并发操作 = 终态持久化层 + 终态声明（具备同步机制）+ 控制器（具备收敛逻辑）**
> 

这是一种可套用的工程公式（Pattern），遵循这个套路，你会发现并发逻辑不再混乱，而是自然地被“状态驱动”所约束。

## 终态持久化层：记录真相的地方

系统中的每个对象，都需要有一个“真实的、持久化的状态源”，它是整个操作的锚点。

这一层的关键要求是：**能记录终态，并支持原子化的 CAS（Compare-And-Swap）操作。**

典型实现包括：

- **Etcd**（基于 Raft 协议）
- **ZooKeeper**（基于 ZAB 协议）
- **MySQL**（借助唯一索引或事务实现乐观锁）
- 其它具备一致性写入的存储系统

终态持久化层的核心作用是：

1. 让对象的目标状态（Desired State）可被可靠地持久化；
2. 提供一种可以安全修改状态的同步机制（CAS / 乐观锁 / 版本号控制）。

换句话说，这一层相当于 Kubernetes 中的 Etcd：它不执行操作，但它记录了“真相”。

## 终态声明：定义你想要的世界

终态声明描述了系统中每个对象“期望达到的最终状态”。

例如，一个节点可以处于以下状态：

> 创建中 → 已创建 → 升级中 → 已升级 → 删除中 → 已删除
> 

每一次状态的修改，实际上是一次“声明的更新”过程。

为了避免并发竞争导致的状态错乱（例如两个控制器同时尝试升级同一节点），**我们必须使用同步机制来保护终态修改的原子性。**

最常见的手段包括：

- **分布式锁**（适合松散一致场景）
- **CAS / 乐观锁机制**（适合严格一致场景）

终态声明的过程，就是告诉系统：“我希望这个资源的目标状态变为 X”。

但系统此时**不会立即执行操作**，而是等待控制器去收敛状态。

## 控制器：让世界朝着声明前进

有了终态持久化层、终态声明，加上合适的同步机制，我们可以保证：

1. 对象的终态被会持久化记录。
2. 对象的终态是一个合理的终态。

控制器（Controller）是整个声明式并发模型的灵魂。它的职责是持续观察当前状态（Actual State），并与期望状态（Desired State）对比：

- 如果当前状态偏离终态，控制器就执行必要的动作（创建、更新、重试等）；
- 如果终态已经达成，控制器则保持静默，直到下次声明变化。

这种机制与 Kubernetes 的控制循环极其相似：

你定义“我想要三个副本”，控制器就不断检查并修复，直到系统的实际状态满足声明。

在并发场景下，这意味着：

即使有多个控制器同时运行，只要终态声明受同步保护、终态持久化层具备一致性，系统最终也会收敛到正确的状态。

![image.png](https://ahan-io.notion.site/image/attachment%3Ae326ecef-0994-44c2-94f6-2eb5f1383049%3Aimage.png?table=block&id=2b6eda9f-236a-8002-948f-c92966dc83f5&spaceId=3841c813-6aff-406c-8c94-6fa3c0018b15&width=1420&userId=&cache=v2)

在实际实现中，一个重要原则是：

> 不要“一次做完”，而是“小步快跑”。
> 

每次操作后，都应重新读取当前的终态，再决定下一步动作。

这样系统能更快地感知状态变化，及时响应干扰或冲突。

与其追求“一次到位”，不如让系统在每次“微小的修正”中逐步趋稳——这正是声明式设计的精髓。

将以上三部分合并，我们得到声明式并发的核心模式：

> 声明式并发操作 = 终态持久化层（记录真相） + 终态声明（定义目标） + 控制器（实现收敛）
> 

这套模式将复杂的并发逻辑转化为“状态声明 + 状态收敛”两步，让系统能够在高并发、部分失败和异步操作中依然保持确定性与可预测性。

在分布式世界中，这种范式不仅减少了锁的使用，更让系统具备了**自我纠偏的能力**。

# 示例

在分布式场景下，一个看似简单的创建操作，往往并不只涉及单个服务。比如，当用户创建一个资源时，系统可能需要**先在元数据服务写入描述信息**，再**在数据服务实际分配存储空间**。

这种“跨服务”的多资源创建，本质上是一种**分布式事务问题**。为了系统的可靠性，我们希望：

> 不同服务上的资源，要么最终都被创建成功，要么最终都能被清理干净，不留垃圾。
> 

假设现在有一个创建资源 `r` 的请求，它需要依次调用两个服务：

- **服务 A**：负责创建资源 `a`（例如某个卷或对象）；
- **服务 B**：负责记录资源 `a` 的容量或配额（用于用量统计）。

只有当 A、B 都成功时，整个创建操作才算成功。此时 `a` 与 `b` 是一一对应的。

然而，在真实世界中，失败往往是常态。例如：调用服务 A 成功，而调用服务 B 失败了。这种部分成功的情况极其常见，也是系统产生“垃圾资源”的主要来源。

对于这种情况，我们通常有三种处理思路：

1. **回滚式处理（Rollback Approach）**
    
    即请求整体失败，同时回滚资源 `a` 与 `b` 的创建。
    
    这种方式听起来最“干净”，但实现起来很困难。因为“回滚”本身也可能失败，需要有重试与幂等机制来确保最终一致性。更复杂的是，进程重启或任务迁移后，还要有机制确保回滚能“最终被执行”。
    
2. **声明式清理（Declarative Cleanup Approach）** ✅ *推荐*
    
    如果回滚代价太高，可以让请求直接以失败结束，但在系统中留下一个“可见”的失败记录 `r`。
    
    用户在控制台或 API 中能看到这个失败的资源，当用户发起删除时，系统会将其标记为 **“删除中”**。
    
    后台的控制器（Controller）会周期性扫描这些“删除中”的资源，通过声明式机制不断尝试清理 `a` 与 `b`，直到彻底删除成功。
    
    这种方式的优势在于：用户可见、系统可控、清理可重试，是一种更稳健的工程策略。
    
3. **延迟对账（Reconciliation Approach）**
    
    如果服务 B 的创建并不是强一致需求（例如容量上报，对用户体验影响较小），我们可以让请求“看起来成功”，从而提升用户体验。
    
    服务 A 与服务 B 之间再通过**周期性对账**，确保两边的资源最终一致。
    
    这种方式本质上也是一种声明式范式：
    
    > “系统声明 A、B 两边的状态应当一致，然后通过持续比对与修正，逼近这一终态。”
    >